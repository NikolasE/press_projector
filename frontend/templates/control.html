<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Press Projector Control</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="manifest" href="/static/site.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            overflow-x: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .main-container {
            display: flex;
            min-height: calc(100vh - 80px);
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 1rem;
            overflow-y: auto;
        }

        .content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .tab-container {
            display: none;
        }

        .tab-container.active {
            display: block;
        }

        .tab-buttons {
            display: flex;
            background: #ecf0f1;
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .tab-button {
            flex: 1;
            padding: 0.75rem;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tab-button.active {
            background: #3498db;
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #bdc3c7;
        }

        .setup-tab-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            z-index: 1000;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-connected {
            background: #27ae60;
        }

        .status-disconnected {
            background: #e74c3c;
        }

        .calibration-points {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .calibration-point {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            background: #f8f9fa;
        }

        .calibration-point h4 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .coordinate-inputs {
            display: flex;
            gap: 0.5rem;
        }

        .coordinate-inputs input {
            flex: 1;
        }

        .layout-canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            position: relative;
            min-height: 400px;
            margin-bottom: 1rem;
        }

        .element-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5rem;
        }

        .element-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .element-item:hover {
            background-color: #f8f9fa;
        }

        .element-item:last-child {
            border-bottom: none;
        }

        .element-item.selected {
            background-color: #e8f4fb;
            border-left: 3px solid #3498db;
        }

        /* Blinking animation will be applied directly via JavaScript to SVG elements */

        .element-controls {
            display: flex;
            gap: 0.25rem;
        }

        .element-controls button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 2px;
        }

        .element-controls button:hover {
            background: #f8f9fa;
        }

        .file-upload {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .file-upload:hover {
            border-color: #3498db;
        }

        .file-upload.dragover {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .file-list {
            margin-top: 1rem;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .alert {
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Press Projector Control</h1>
    </div>

    <button class="setup-tab-button" onclick="toggleSetupMode()">Setup & Maintenance</button>

    <div class="main-container">
        <div class="sidebar">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('layout')">Layout</button>
                <button class="tab-button" onclick="switchTab('files')">Files</button>
            </div>

            <!-- Layout Tab -->
            <div id="layout-tab" class="tab-container active">
                <h3>Layout Editor</h3>
                
                <div class="form-group">
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <label style="margin:0;">Orientation</label>
                        <input type="number" id="objectOrientation" placeholder="0" step="0.1" oninput="updateObjectOrientation()" onchange="updateObjectOrientation()" style="width:80px;">
                    </div>
                </div>

                <div class="form-group">
                    <label>Center Lines (mm)</label>
                    <div>
                        <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.5rem;">
                            <span style="min-width:100px;">Vertical (X)</span>
                            <input type="text" id="centerLineH" placeholder="Horizontal Y" oninput="updateCenterLines()" onchange="updateCenterLines()" style="width:8ch;">
                        </div>
                        <div style="display:flex; align-items:center; gap:0.5rem;">
                            <span style="min-width:100px;">Horizontal (Y)</span>
                            <input type="text" id="centerLineV" placeholder="Vertical X" oninput="updateCenterLines()" onchange="updateCenterLines()" style="width:8ch;">
                        </div>
                    </div>
                </div>

                <h4>Drawing Tools</h4>
                <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn" onclick="addLine()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">📏 Add Line</button>
                    <button class="btn" onclick="addRectangle()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">▭ Add Rectangle</button>
                    <button class="btn" onclick="addCircle()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">○ Add Circle</button>
                    <button class="btn" onclick="addText()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">🔤 Add Text</button>
                    <button class="btn" onclick="addImage()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">🖼️ Add Image</button>
                </div>

                <h4>Elements</h4>
                <div style="display:flex; gap:0.5rem; margin: 0.25rem 0 0.75rem 0;">
                    <button class="btn" style="background:#e74c3c;" onclick="startNewScene()">🆕 New</button>
                </div>
                <div class="element-list" id="elementList">
                    <!-- Elements will be added here dynamically -->
                </div>

                <div id="nudgeControls" style="margin-top:0.5rem; display:none;">
                    <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:0.25rem; width: 100%; max-width: 260px;">
                        <div></div>
                        <button class="btn" style="padding:0.2rem; aspect-ratio:2; width:100%;" onclick="nudgeSelected(0,-1)" title="Up (1 mm)">⬆️</button>
                        <div></div>
                        <button class="btn" style="padding:0.2rem; aspect-ratio:2; width:100%;" onclick="nudgeSelected(-1,0)" title="Left (1 mm)">⬅️</button>
                        <button class="btn" style="padding:0.2rem; aspect-ratio:2; width:100%;" onclick="nudgeSelected(0,1)" title="Down (1 mm)">⬇️</button>
                        <button class="btn" style="padding:0.2rem; aspect-ratio:2; width:100%;" onclick="nudgeSelected(1,0)" title="Right (1 mm)">➡️</button>
                    </div>
                    <div style="display:flex; gap:0.25rem; margin-top:0.25rem; justify-content:center;">
                        <button class="btn" style="padding:0.2rem; width:33%; aspect-ratio:2;" onclick="rotateSelected(-Math.PI/180)" title="Rotate -1°">⟲ -1°</button>
                        <button class="btn" style="padding:0.2rem; width:33%; aspect-ratio:2;" onclick="rotateSelected(Math.PI/180)" title="Rotate +1°">⟳ +1°</button>
                    </div>
                    <div style="color:#666; font-size:0.85rem; margin-top:0.25rem; text-align:center;">Keyboard: arrows to move 1mm; Shift+Left/Right to rotate 1°</div>
                </div>

                <h4 style="margin-top: 1rem;">Saved Scenes</h4>
                <div class="form-group" style="display:flex; gap:0.5rem; align-items:center;">
                    <input type="text" id="configName" placeholder="Scene name">
                    <button class="btn btn-success" onclick="saveConfiguration()">Save</button>
                </div>

                <div class="element-list" id="configurationList">
                    <!-- Configurations will be listed here -->
                </div>
            </div>

            <!-- Files Tab -->
            <div id="files-tab" class="tab-container">
                <h3>File Management</h3>
                
                <div class="file-upload" id="fileUpload" onclick="document.getElementById('fileInput').click()">
                    <p>Click to upload or drag files here</p>
                    <input type="file" id="fileInput" style="display: none" multiple accept=".png,.jpg,.jpeg,.svg" onchange="handleFileUpload()">
                </div>

                <div class="file-list" id="fileList">
                    <!-- Files will be listed here -->
                </div>
            </div>

            
        </div>

        <div class="content">
            <div id="main-content">
                <h2>Press Projector System</h2>
                <p>Use the sidebar to calibrate the system and create layout configurations.</p>
                
                <div id="alerts">
                    <!-- Alerts will be shown here -->
                </div>

                <!-- Real-time Control Preview (press area only) -->
                <div id="layoutPreviewContainer" style="margin-top: 1rem; background:#1a1a1a; border:1px solid #333; border-radius:8px; padding:8px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; color:#ddd; margin-bottom:8px;">
                        <span>Control Preview (press area)</span>
                        <span id="previewSize" style="font-size:0.85rem; opacity:0.8;"></span>
                    </div>
                    <div id="layoutPreview" style="width:100%; height:60vh; display:flex; align-items:center; justify-content:center; background:#111; border-radius:4px; overflow:hidden;"></div>
                </div>
                <div id="alertsBelow" style="margin-top: 0.75rem;"></div>
            </div>
        </div>
    </div>

    <!-- Setup & Maintenance Tab (Hidden by default) -->
    <div id="setup-tab" class="tab-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 9999; padding: 2rem; overflow-y: auto;">
        <div style="max-width: 800px; margin: 0 auto;">
            <h2>Setup & Maintenance</h2>
            
            <!-- Calibration Section -->
            <div style="margin-bottom: 2rem; padding: 1.5rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #ddd;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3>Press Calibration</h3>
                    <button class="btn" onclick="toggleCalibrationGuide()" style="background: #3498db; padding: 0.5rem 1rem; font-size: 0.9rem;">
                        📖 View Calibration Guide
                    </button>
                </div>
                
                <!-- Calibration Guide (Hidden by default) -->
                <div id="calibrationGuide" style="display: none; margin-bottom: 1rem; padding: 1rem; background: white; border-radius: 8px; border: 1px solid #ddd; max-height: 600px; overflow-y: auto;">
                    <h4>Calibration Guide</h4>
                    <div id="calibrationGuideContent"></div>
                </div>
                
                <div class="form-group">
                    <label>Press Dimensions (mm)</label>
                    <div>
                        <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.5rem;">
                            <span style="min-width:60px;">Width</span>
                            <input type="text" id="pressWidth" placeholder="Width" oninput="renderControlPreview()" onchange="renderControlPreview()" style="width:8ch;">
                        </div>
                        <div style="display:flex; align-items:center; gap:0.5rem;">
                            <span style="min-width:60px;">Height</span>
                            <input type="text" id="pressHeight" placeholder="Height" oninput="renderControlPreview()" onchange="renderControlPreview()" style="width:8ch;">
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button class="btn" onclick="toggleInteractiveCalibration()" id="startCalibrationBtn">
                            🎯 Start Interactive Calibration
                        </button>
                    </div>
                </div>

                <!-- Calibration Preview and Controls (hidden by default) -->
                <div id="calibrationPreviewControls" style="display: none; margin-top: 1.5rem;">
                    <h4>Calibration Corner Adjustments</h4>
                    
                    <!-- SVG Preview -->
                    <div id="calibrationPreview" style="position: relative; border: 2px solid #ddd; border-radius: 8px; overflow: hidden; background: #000; margin-bottom: 1rem; min-height: 200px;">
                        <!-- SVG will be rendered here dynamically -->
                    </div>
                    
                    <!-- Corner Selection and Arrow Controls -->
                    <div style="margin-bottom: 1rem;">
                        <div style="color: #666; font-size: 0.9rem; margin-bottom: 0.5rem;">Click a corner to select it, then use arrow buttons or keyboard to adjust</div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; max-width: 300px;">
                            <div></div>
                            <button class="btn" style="padding: 0.5rem; aspect-ratio: 2;" onclick="nudgeCalibrationCorner(0, -1)" title="Up (1 px)">⬆️</button>
                            <div></div>
                            <button class="btn" style="padding: 0.5rem; aspect-ratio: 2;" onclick="nudgeCalibrationCorner(-1, 0)" title="Left (1 px)">⬅️</button>
                            <button class="btn" style="padding: 0.5rem; aspect-ratio: 2;" onclick="nudgeCalibrationCorner(0, 1)" title="Down (1 px)">⬇️</button>
                            <button class="btn" style="padding: 0.5rem; aspect-ratio: 2;" onclick="nudgeCalibrationCorner(1, 0)" title="Right (1 px)">➡️</button>
                        </div>
                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.5rem;">Keyboard: arrows to move 1px (when corner selected)</div>
                    </div>
                </div>

                <button class="btn" id="validateBtn" onclick="validateCalibration()">Show configured Area</button>
            </div>
            
            

            

            <button class="btn btn-danger" id="closeSetupBtn" onclick="toggleSetupMode()" style="display:block; margin: 1rem auto 0 auto;">Close Setup</button>
        </div>
    </div>

    <!-- Element Editor Modal -->
    <div id="elementEditor" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 1rem; border-radius: 8px; width: 320px; max-width: 90vw; box-shadow: 0 10px 30px rgba(0,0,0,0.25);">
            <h3 style="margin-bottom: 0.75rem;">Edit Element</h3>
            <div class="form-group" style="margin-bottom:0.75rem;">
                <label>Label</label>
                <input type="text" id="eeLabel">
            </div>
            <!-- Common position and rotation fields for most element types -->
            <div id="eeCommonFields" style="display:none;">
                <div class="form-group" style="margin-bottom:0.75rem; display:flex; gap:0.5rem;">
                    <div style="flex:1;">
                        <label>X (mm)</label>
                        <input type="text" id="eeX">
                    </div>
                    <div style="flex:1;">
                        <label>Y (mm)</label>
                        <input type="text" id="eeY">
                    </div>
                </div>
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Rotation (deg)</label>
                    <input type="text" id="eeRotation">
                </div>
            </div>

            <!-- Type-specific additional fields -->
            <div id="eeRectFields" style="display:none;">
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Width (mm)</label>
                    <input type="text" id="eeWidth">
                </div>
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Height (mm)</label>
                    <input type="text" id="eeHeight">
                </div>
            </div>
            <div id="eeLineFields" style="display:none;">
                <div style="font-size:0.85rem; color:#666; margin-top:0.25rem; margin-bottom:0.5rem;">Length stays unchanged; edits reposition and rotate the line.</div>
            </div>
            <div id="eeCircleFields" style="display:none;">
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Radius (mm)</label>
                    <input type="text" id="eeRadius">
                </div>
            </div>
            <div id="eeTextFields" style="display:none;">
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Font size (mm)</label>
                    <input type="text" id="eeTextSize">
                </div>
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Text</label>
                    <input type="text" id="eeTextContent">
                </div>
            </div>
            <div id="eeImageFields" style="display:none;">
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Width (mm)</label>
                    <input type="number" id="eeImageWidth" step="0.1" min="0">
                </div>
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Rotation (deg)</label>
                    <input type="number" id="eeImageRotation" step="0.1">
                </div>
                <div class="form-group" style="margin-bottom:0.75rem;">
                    <label>Opacity</label>
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <input type="range" id="eeImageOpacity" min="0" max="100" step="1" style="flex:1;">
                        <input type="number" id="eeImageOpacityNum" min="0" max="100" step="1" style="width:6ch;">
                        <span>%</span>
                    </div>
                </div>
            </div>
            <div class="form-group" style="margin-bottom:0.75rem;">
                <label>Color</label>
                <input type="color" id="eeColor">
            </div>
            <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top: 0.5rem;">
                <button class="btn" style="background:#7f8c8d;" onclick="closeElementEditor()">Cancel</button>
                <button class="btn btn-success" onclick="saveElementEditor()">Save</button>
            </div>
        </div>
    </div>

    <!-- Image Selection Modal -->
    <div id="imageSelectionModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 1.5rem; border-radius: 8px; width: 600px; max-width: 90vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.25);">
            <h3 style="margin-bottom: 1rem;">Select Image</h3>
            <div id="imageSelectionList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                <!-- Images will be added here dynamically -->
            </div>
            <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
                <button class="btn" style="background:#7f8c8d;" onclick="closeImageSelection()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Stop Calibration Confirmation Modal -->
    <div id="stopCalibrationModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 1rem; border-radius: 8px; width: 340px; max-width: 90vw; box-shadow: 0 10px 30px rgba(0,0,0,0.25);">
            <h3 style="margin-bottom: 0.5rem;">Stop Calibration?</h3>
            <p style="margin-bottom: 1rem; color:#333;">Do you want to store the calibration or discard it?</p>
            <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
                <button class="btn btn-success" id="scmStoreBtn" onclick="onStoreCalibrationFromModal()">Store Calibration</button>
                <button class="btn" style="background:#7f8c8d;" onclick="onDiscardCalibrationFromModal()">Discard</button>
            </div>
        </div>
    </div>

    <!-- Delete Element Confirmation Modal -->
    <div id="deleteElementModal" onclick="if(event.target===this) hideDeleteElementModal()" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 1.5rem; border-radius: 8px; width: 380px; max-width: 90vw; box-shadow: 0 10px 30px rgba(0,0,0,0.25);">
            <h3 style="margin-bottom: 0.75rem; color:#e74c3c;">Delete Element</h3>
            <p style="margin-bottom: 1.5rem; color:#555;">Are you sure you want to delete <strong id="deleteElementName">this element</strong>? This action cannot be undone.</p>
            <div style="display:flex; gap:0.75rem; justify-content:flex-end;">
                <button class="btn" style="background:#7f8c8d;" onclick="hideDeleteElementModal()">Cancel</button>
                <button class="btn" style="background:#e74c3c;" id="deleteConfirmBtn" onclick="confirmDeleteElement()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div id="confirmModal" onclick="if(event.target===this) hideConfirmModal()" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 1.5rem; border-radius: 8px; width: 420px; max-width: 90vw; box-shadow: 0 10px 30px rgba(0,0,0,0.25);">
            <h3 style="margin-bottom: 0.75rem; color:#2c3e50;">Please Confirm</h3>
            <p id="confirmMessage" style="margin-bottom: 1.5rem; color:#555;">Are you sure?</p>
            <div style="display:flex; gap:0.75rem; justify-content:flex-end;">
                <button class="btn" style="background:#7f8c8d;" onclick="hideConfirmModal()">Cancel</button>
                <button class="btn btn-success" id="confirmOkBtn" onclick="confirmFromModal()">Confirm</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <!-- SVG.js for frontend SVG composition and interactions -->
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
    <!-- SVG.js draggable plugin -->
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.draggable.js@3.0.3/dist/svg.draggable.min.js"></script>
    <script src="/static/common.js"></script>
    <script>
        // Global state
        let currentLayout = {
            object_orientation: 0,
            center_lines: { horizontal: null, vertical: null },
            elements: []
        };

        let elements = [];
        let files = [];
        let configurations = [];
        let selectedElementIndex = -1;

        // Guard to accept only a single orientation change per continuous spinner hold
        const orientationSpinHold = { active: false, processed: false };

        function toAbsoluteUrl(url) {
            if (!url) return '';
            if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:')) return url;
            try { return window.location.origin + url; } catch (e) { return url; }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeWebSocket();
            loadFiles();
            loadConfigurations();
            updateElementList();
            setupNumericInputs();
            // Attempt to auto-load last scene after initial data fetch
            fetchLastSceneAndAutoLoad();

            // Setup single-press behavior for object orientation spinner buttons
            const orientationInput = document.getElementById('objectOrientation');
            if (orientationInput) {
                orientationInput.addEventListener('mousedown', function() {
                    orientationSpinHold.active = true;
                    orientationSpinHold.processed = false;
                });
                const resetSpin = function() {
                    orientationSpinHold.active = false;
                    orientationSpinHold.processed = false;
                };
                orientationInput.addEventListener('mouseup', resetSpin);
                orientationInput.addEventListener('mouseleave', resetSpin);
                orientationInput.addEventListener('blur', resetSpin);
            }

            // Wire drag & drop for file uploads
            const dropzone = document.getElementById('fileUpload');
            if (dropzone) {
                const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
                ['dragenter', 'dragover'].forEach(ev => dropzone.addEventListener(ev, (e) => {
                    prevent(e);
                    dropzone.classList.add('dragover');
                }));
                ['dragleave', 'dragend'].forEach(ev => dropzone.addEventListener(ev, (e) => {
                    prevent(e);
                    dropzone.classList.remove('dragover');
                }));
                dropzone.addEventListener('drop', (e) => {
                    prevent(e);
                    dropzone.classList.remove('dragover');
                    const dt = e.dataTransfer;
                    if (dt && dt.files && dt.files.length) {
                        for (let i = 0; i < dt.files.length; i++) {
                            uploadFile(dt.files[i]);
                        }
                    }
                });
            }

            // Prevent browser from opening the file on drop outside the dropzone
            ['dragover', 'drop'].forEach(ev => document.addEventListener(ev, (e) => {
                e.preventDefault();
            }));
        });

        // WebSocket connection
        function initializeWebSocket() {
            // Get the base URL from current location
            const baseUrl = window.location.origin;
            const socket = io(baseUrl, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 10
            });
            
            socket.on('connect', function() {
                updateConnectionStatus(true);
                socket.emit('join_room', { room: 'control' });
            });

            socket.on('disconnect', function() {
                updateConnectionStatus(false);
            });

            socket.on('calibration_updated', function(data) {
                console.log('Calibration updated:', data);
                const cal = (data && data.calibration) ? data.calibration : data;
                if (cal && (cal.press_width_mm != null || cal.press_height_mm != null)) {
                    setPressInputs(cal.press_width_mm, cal.press_height_mm);
                    renderControlPreview();
                }
                showAlert('Calibration updated successfully', 'success');
            });

            socket.on('layout_updated', function(data) {
                console.log('Layout updated:', data);
                currentLayout = data.layout;
                updateLayoutForm();
            });

            socket.on('calibration_point_dragged', function(data) {
                console.log('Calibration point dragged:', data);
                updateCalibrationPoint(calibrationPoints[data.index].id, data.x, data.y);
                // Update the preview
                renderCalibrationPreview();
            });

            socket.on('calibration_point_selected', function(data) {
                console.log('Calibration point selected:', data);
                // Select the corner in the control preview
                selectCalibrationCorner(data.index);
            });

            socket.on('update_calibration_points', function(data) {
                console.log('Updating calibration points from projector:', data);
                if (data.points && data.points.length === 4) {
                    // Update the calibration points array
                    calibrationPoints = data.points.map(p => ({ id: p.id || '', x: p.x, y: p.y, label: p.label || '' }));
                    // Re-render the preview
                    renderCalibrationPreview();
                }
            });

            // Store socket globally
            window.socket = socket;
        }

        // Numeric input enforcement
        function enforceNumericInput(el, options) {
            if (!el) return;
            const allowNegative = !!(options && options.allowNegative);
            const allowDecimal = options && options.allowDecimal !== false; // default true
            el.addEventListener('beforeinput', (e) => {
                if (e.inputType !== 'insertText') return;
                const ch = e.data;
                if (ch == null) return;
                const isDigit = ch >= '0' && ch <= '9';
                if (isDigit) return;
                if (ch === '.' ) {
                    if (!allowDecimal) { e.preventDefault(); return; }
                    if (el.value.includes('.')) { e.preventDefault(); return; }
                    return;
                }
                if (ch === '-') {
                    if (!allowNegative) { e.preventDefault(); return; }
                    // only allow minus at start and only once
                    const atStart = (el.selectionStart || 0) === 0;
                    if (!atStart || el.value.includes('-')) { e.preventDefault(); return; }
                    return;
                }
                // block all other characters (e/E/+ etc.)
                e.preventDefault();
            });
            el.addEventListener('keydown', (e) => {
                // block exponential and plus
                if (e.key === 'e' || e.key === 'E' || e.key === '+') {
                    e.preventDefault();
                }
            });
        }

        function setupNumericInputs() {
            // Calibration form
            enforceNumericInput(document.getElementById('pressWidth'),  { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('pressHeight'), { allowNegative: false, allowDecimal: true });

            // Layout controls
            enforceNumericInput(document.getElementById('objectOrientation'), { allowNegative: true, allowDecimal: true });
            enforceNumericInput(document.getElementById('centerLineH'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('centerLineV'), { allowNegative: false, allowDecimal: true });

            // Element editor fields (may be hidden but present in DOM)
            // Common position/rotation fields
            enforceNumericInput(document.getElementById('eeX'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('eeY'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('eeRotation'), { allowNegative: true, allowDecimal: true });
            // Type-specific fields
            enforceNumericInput(document.getElementById('eeWidth'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('eeHeight'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('eeRadius'), { allowNegative: false, allowDecimal: true });
            enforceNumericInput(document.getElementById('eeTextSize'), { allowNegative: false, allowDecimal: true });
        }

        function updateConnectionStatus(connected) {
            const el = document.getElementById('projectorStatus');
            if (!el) return;
            el.textContent = connected ? 'Connected' : 'Disconnected';
            el.style.color = connected ? '#27ae60' : '#e74c3c';
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-container').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Setup mode toggle
        function toggleSetupMode() {
            const setupTab = document.getElementById('setup-tab');
            setupTab.style.display = setupTab.style.display === 'none' ? 'block' : 'none';
        }

        // Calibration functions
        let calibrationMode = false;
        let selectedCalibrationCorner = null; // Index of selected corner (0-3) or null
        let calibrationPoints = [
            { id: 'tl', x: 0, y: 0, label: 'Top Left' },
            { id: 'tr', x: 0, y: 0, label: 'Top Right' },
            { id: 'br', x: 0, y: 0, label: 'Bottom Right' },
            { id: 'bl', x: 0, y: 0, label: 'Bottom Left' }
        ];

        function toggleCalibrationGuide() {
            const guideDiv = document.getElementById('calibrationGuide');
            const button = event.target;
            
            if (guideDiv.style.display === 'none') {
                guideDiv.style.display = 'block';
                button.textContent = '📖 Hide Calibration Guide';
                loadCalibrationGuide();
            } else {
                guideDiv.style.display = 'none';
                button.textContent = '📖 View Calibration Guide';
            }
        }

        function loadCalibrationGuide() {
            const contentDiv = document.getElementById('calibrationGuideContent');
            
            // Guide content in HTML format
            const guideHTML = `
                <div style="line-height: 1.6;">
                    <h5 style="color: #2c3e50; margin-top: 0;">How Calibration Works</h5>
                    <p>The calibration system uses <strong>OpenCV's perspective transformation</strong> to map points from the projector's coordinate system (pixels) to the press's physical coordinate system (millimeters). This corrects for:</p>
                    <ul>
                        <li><strong>Perspective distortion</strong> when the projector is not perfectly perpendicular to the press</li>
                        <li><strong>Scale differences</strong> between projector pixels and real-world measurements</li>
                        <li><strong>Rotation</strong> if the projector is slightly rotated</li>
                    </ul>

                    <h5 style="color: #2c3e50; margin-top: 1.5rem;">Step-by-Step Instructions</h5>
                    
                    <h6 style="color: #3498db; margin-top: 1rem;">Step 1: Measure Press Dimensions</h6>
                    <ol>
                        <li><strong>Measure the press area</strong> that will be used for printing
                            <ul>
                                <li>Measure <strong>width</strong> in millimeters (left to right)</li>
                                <li>Measure <strong>height</strong> in millimeters (top to bottom)</li>
                                <li>Note: Measure the actual usable press area, not the entire press</li>
                            </ul>
                        </li>
                        <li><strong>Enter dimensions</strong> in the calibration form above</li>
                    </ol>

                    <h6 style="color: #3498db; margin-top: 1rem;">Step 2: Mark Corner Points</h6>
                    <p>You need to mark <strong>4 corner points</strong> where the projector image corners align with the press corners.</p>
                    
                    <div style="background: #e8f4f8; padding: 1rem; border-radius: 4px; margin: 0.5rem 0;">
                        <strong>Option A: Using Projector View (Recommended)</strong>
                        <ol>
                            <li>Open the <strong>Setup & Maintenance</strong> tab (red button in top-right)</li>
                            <li>Click <strong>"Toggle Boundary Pattern"</strong> to show a rectangle outline</li>
                            <li>Position the projector so the rectangle aligns with the press corners</li>
                            <li>Note the pixel coordinates shown at each corner</li>
                        </ol>
                    </div>

                    <div style="background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 0.5rem 0;">
                        <strong>Option B: Manual Point Entry</strong>
                        <ol>
                            <li>On the <strong>press area</strong>, mark the 4 corners</li>
                            <li>For each corner, determine the <strong>projector pixel coordinates</strong></li>
                            <li>Enter these values in the calibration form</li>
                        </ol>
                    </div>

                    <h6 style="color: #3498db; margin-top: 1rem;">Step 3: Enter Calibration Points</h6>
                    <p>Enter the corner points in the form above. Points must be entered in <strong>clockwise or counter-clockwise order</strong> starting from top-left.</p>

                    <h6 style="color: #3498db; margin-top: 1rem;">Step 4: Save Calibration</h6>
                    <ol>
                        <li>Click <strong>"Save Calibration"</strong></li>
                        <li>The system will automatically validate the calibration quality</li>
                        <li>Check the quality metrics displayed below</li>
                    </ol>

                    <h6 style="color: #3498db; margin-top: 1rem;">Step 5: Verify Calibration Quality</h6>
                    <p>After saving, check the <strong>calibration quality metrics</strong>:</p>
                    <ul>
                        <li><strong>Maximum Error</strong>: Should be <strong>&lt; 1.0 mm</strong></li>
                        <li><strong>Average Error</strong>: Should be <strong>&lt; 0.5 mm</strong></li>
                        <li><strong>Status</strong>: Should show <strong>"Valid"</strong></li>
                    </ul>

                    <h5 style="color: #2c3e50; margin-top: 1.5rem;">Quality Guidelines</h5>
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 0.5rem; border: 1px solid #ddd;">Quality Level</th>
                                <th style="padding: 0.5rem; border: 1px solid #ddd;">Max Error</th>
                                <th style="padding: 0.5rem; border: 1px solid #ddd;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #ddd; color: #27ae60;"><strong>Excellent</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">&lt; 0.5 mm</td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">✓ Perfect</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #ddd; color: #27ae60;"><strong>Good</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">&lt; 1.0 mm</td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">✓ Acceptable</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #ddd; color: #3498db;"><strong>Acceptable</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">&lt; 2.0 mm</td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">⚠ Works but could improve</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #ddd; color: #e74c3c;"><strong>Poor</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">&gt; 2.0 mm</td>
                                <td style="padding: 0.5rem; border: 1px solid #ddd;">✗ Recalibration required</td>
                            </tr>
                        </tbody>
                    </table>

                    <h5 style="color: #2c3e50; margin-top: 1.5rem;">Visual Verification</h5>
                    <ol>
                        <li><strong>Use Boundary Pattern</strong>:
                            <ul>
                                <li>Go to Setup & Maintenance</li>
                                <li>Toggle boundary pattern ON</li>
                                <li>The yellow rectangle should align perfectly with press corners</li>
                                <li>Check all 4 corners match exactly</li>
                            </ul>
                        </li>
                        <li><strong>Test with Known Points</strong>:
                            <ul>
                                <li>Place an object at a known position (e.g., 50mm from left, 50mm from top)</li>
                                <li>Create a guide element at that position</li>
                                <li>Verify the projected guide aligns with the object</li>
                            </ul>
                        </li>
                    </ol>

                    <h5 style="color: #2c3e50; margin-top: 1.5rem;">Common Issues & Solutions</h5>
                    
                    <div style="background: #f8d7da; padding: 1rem; border-radius: 4px; margin: 0.5rem 0; border-left: 4px solid #e74c3c;">
                        <strong>Issue: High Error (&gt; 2mm)</strong>
                        <ul style="margin: 0.5rem 0 0 0;">
                            <li>Re-measure corner points more carefully</li>
                            <li>Ensure projector is stable and hasn't moved</li>
                            <li>Check if projector angle is too extreme</li>
                        </ul>
                    </div>

                    <div style="background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 0.5rem 0; border-left: 4px solid #ffc107;">
                        <strong>Issue: Calibration Valid but Guides Don't Match</strong>
                        <ul style="margin: 0.5rem 0 0 0;">
                            <li>Check object orientation angle</li>
                            <li>Verify center line positions</li>
                            <li>Ensure layout elements use correct coordinate system</li>
                        </ul>
                    </div>

                    <div style="background: #d1ecf1; padding: 1rem; border-radius: 4px; margin: 0.5rem 0; border-left: 4px solid #17a2b8;">
                        <strong>Issue: Boundary Pattern Doesn't Align</strong>
                        <ul style="margin: 0.5rem 0 0 0;">
                            <li>Projector may have moved - recalibrate</li>
                            <li>Verify calibration points entered correctly</li>
                            <li>Check press dimensions match actual measurements</li>
                        </ul>
                    </div>

                    <h5 style="color: #2c3e50; margin-top: 1.5rem;">Best Practices</h5>
                    <ul>
                        <li><strong>Stable Setup</strong>: Ensure projector is mounted securely</li>
                        <li><strong>Good Lighting</strong>: Adequate lighting helps see projected guides</li>
                        <li><strong>Accurate Measurements</strong>: Use precise measuring tools</li>
                        <li><strong>Multiple Points</strong>: Test calibration at multiple positions</li>
                        <li><strong>Regular Checks</strong>: Use boundary pattern periodically to verify alignment</li>
                    </ul>
                </div>
            `;
            
            contentDiv.innerHTML = guideHTML;
        }

        function toggleInteractiveCalibration() {
            if (calibrationMode) {
                showStopCalibrationModal();
            } else {
                startInteractiveCalibration();
            }
        }

        function startInteractiveCalibration() {
            const width = parseFloat(document.getElementById('pressWidth').value);
            const height = parseFloat(document.getElementById('pressHeight').value);
            
            if (!width || !height) {
                showAlert('Please enter press dimensions first', 'error');
                return;
            }
            
            calibrationMode = true;
            selectedCalibrationCorner = null; // Reset selection
            document.getElementById('startCalibrationBtn').textContent = '🛑 Stop Calibration';
            document.getElementById('startCalibrationBtn').style.background = '#e74c3c';
            
            // Disable Close Setup button
            const closeBtn = document.getElementById('closeSetupBtn');
            if (closeBtn) {
                closeBtn.disabled = true;
                closeBtn.style.opacity = '0.5';
                closeBtn.style.cursor = 'not-allowed';
            }
            
            // Show calibration preview controls
            const previewControls = document.getElementById('calibrationPreviewControls');
            if (previewControls) {
                previewControls.style.display = 'block';
            }
            
            // Calculate initial rectangle (25% of screen, centered)
            const screenWidth = 1920; // Default projector resolution
            const screenHeight = 1080;
            const rectWidth = screenWidth * 0.25;
            const rectHeight = screenHeight * 0.25;
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            
            // Set initial calibration points
            calibrationPoints[0] = { id: 'tl', x: centerX - rectWidth/2, y: centerY - rectHeight/2, label: 'Top Left' };
            calibrationPoints[1] = { id: 'tr', x: centerX + rectWidth/2, y: centerY - rectHeight/2, label: 'Top Right' };
            calibrationPoints[2] = { id: 'br', x: centerX + rectWidth/2, y: centerY + rectHeight/2, label: 'Bottom Right' };
            calibrationPoints[3] = { id: 'bl', x: centerX - rectWidth/2, y: centerY + rectHeight/2, label: 'Bottom Left' };
            
            // Render the preview
            renderCalibrationPreview();
            
            // Send calibration rectangle to projector
            if (window.socket) {
                try { window.socket.emit('set_projection_mode', { mode: 'svg' }); } catch (e) {}
                window.socket.emit('start_calibration', {
                    points: calibrationPoints,
                    press_width_mm: width,
                    press_height_mm: height
                });
            }
        }

        function stopInteractiveCalibration() {
            calibrationMode = false;
            selectedCalibrationCorner = null; // Reset selection
            document.getElementById('startCalibrationBtn').textContent = '🎯 Start Interactive Calibration';
            document.getElementById('startCalibrationBtn').style.background = '#3498db';
            
            // Enable Close Setup button
            const closeBtn = document.getElementById('closeSetupBtn');
            if (closeBtn) {
                closeBtn.disabled = false;
                closeBtn.style.opacity = '1';
                closeBtn.style.cursor = 'pointer';
            }
            
            // Hide calibration preview controls
            const previewControls = document.getElementById('calibrationPreviewControls');
            if (previewControls) {
                previewControls.style.display = 'none';
            }
            
            // Stop calibration on projector
            if (window.socket) {
                try { window.socket.emit('set_projection_mode', { mode: 'frames' }); } catch (e) {}
                window.socket.emit('stop_calibration');
            }
        }

        // Stop Calibration confirmation modal
        function showStopCalibrationModal() {
            const modal = document.getElementById('stopCalibrationModal');
            if (modal) modal.style.display = 'flex';
            // Focus default button for quick keyboard interaction
            try { document.getElementById('scmStoreBtn').focus(); } catch (e) {}
        }

        function hideStopCalibrationModal() {
            const modal = document.getElementById('stopCalibrationModal');
            if (modal) modal.style.display = 'none';
        }

        function onStoreCalibrationFromModal() {
            hideStopCalibrationModal();
            // saveCalibration will also stop interactive mode if active
            saveCalibration();
        }

        function onDiscardCalibrationFromModal() {
            hideStopCalibrationModal();
            stopInteractiveCalibration();
        }


        function updateCalibrationPoint(pointId, x, y) {
            const point = calibrationPoints.find(p => p.id === pointId);
            if (point) {
                point.x = x;
                point.y = y;
                
                // Send updated points to projector
                if (window.socket && calibrationMode) {
                    window.socket.emit('update_calibration_points', {
                        points: calibrationPoints
                    });
                }
            }
        }

        // Select a corner to adjust (pass null to deselect)
        function selectCalibrationCorner(index) {
            if (index !== null && (index < 0 || index > 3)) return;
            selectedCalibrationCorner = index;
            // Re-render to show selection
            renderCalibrationPreview();
        }

        // Render the calibration preview SVG
        function renderCalibrationPreview() {
            const container = document.getElementById('calibrationPreview');
            if (!container || !calibrationPoints || calibrationPoints.length !== 4) {
                return;
            }

            // Use projector aspect ratio
            const width = projectorTarget.width || 1920;
            const height = projectorTarget.height || 1080;
            const aspectRatio = width / height;
            
            // Set container size (max width 600px, maintain aspect ratio)
            const maxWidth = 600;
            const svgWidth = maxWidth;
            const svgHeight = maxWidth / aspectRatio;
            container.style.width = svgWidth + 'px';
            container.style.height = svgHeight + 'px';

            // Scale points from projector resolution to SVG size
            const scaleX = svgWidth / width;
            const scaleY = svgHeight / height;

            // Build points string for polygon
            const pointsStr = calibrationPoints.map(p => {
                const x = (p.x * scaleX).toFixed(1);
                const y = (p.y * scaleY).toFixed(1);
                return `${x},${y}`;
            }).join(' ');

            // Build corner handles
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
            const labels = ['TL', 'TR', 'BR', 'BL'];
            const handles = calibrationPoints.map((point, index) => {
                const x = (point.x * scaleX).toFixed(1);
                const y = (point.y * scaleY).toFixed(1);
                const selected = index === selectedCalibrationCorner;
                const strokeStyle = selected ? 'stroke-width="4" stroke="white"' : 'stroke-width="2" stroke="white"';
                const outerCircle = selected ? `<circle cx="${x}" cy="${y}" r="22" fill="none" stroke="#fff" stroke-width="3" style="pointer-events: none;"/>` : '';
                return `
                    <g class="calibration-handle" data-index="${index}">
                        ${outerCircle}
                        <circle cx="${x}" cy="${y}" r="15" fill="${colors[index]}" ${strokeStyle} style="cursor: grab;" />
                        <text x="${x}" y="${parseFloat(y) + 5}" fill="white" text-anchor="middle" font-size="10" font-weight="bold" style="pointer-events: none;">${labels[index]}</text>
                    </g>
                `;
            }).join('');

            // Build green line for bottom edge (between BL and BR corners, interpolated at 0.1)
            // BL is index 3 (yellow), BR is index 2 (blue)
            // TL is index 0 (red), TR is index 1 (green)
            const topLeft = calibrationPoints[0];   // Red
            const topRight = calibrationPoints[1];  // Green
            const bottomRight = calibrationPoints[2]; // Blue
            const bottomLeft = calibrationPoints[3];  // Yellow
            
            // Interpolate from bottom-left (yellow) towards top-left (red) at 0.1
            // and from bottom-right (blue) towards top-right (green) at 0.1
            const t = 0.1;
            const x1 = bottomLeft.x + (topLeft.x - bottomLeft.x) * t;
            const y1 = bottomLeft.y + (topLeft.y - bottomLeft.y) * t;
            const x2 = bottomRight.x + (topRight.x - bottomRight.x) * t;
            const y2 = bottomRight.y + (topRight.y - bottomRight.y) * t;
            
            // Cut off 20% from each end to avoid touching yellow lines
            const cutPercent = 0.2;
            const x1_cut = x1 + (x2 - x1) * cutPercent;
            const y1_cut = y1 + (y2 - y1) * cutPercent;
            const x2_cut = x2 - (x2 - x1) * cutPercent;
            const y2_cut = y2 - (y2 - y1) * cutPercent;
            
            const blX = (x1_cut * scaleX).toFixed(1);
            const blY = (y1_cut * scaleY).toFixed(1);
            const brX = (x2_cut * scaleX).toFixed(1);
            const brY = (y2_cut * scaleY).toFixed(1);
            const greenLine = `<line x1="${blX}" y1="${blY}" x2="${brX}" y2="${brY}" stroke="#00ff00" stroke-width="4" style="pointer-events: none;"/>`;

            const svgContent = `
                <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <style>
                            .calibration-handle circle:hover { r: 18; }
                            .calibration-handle circle:active { cursor: grabbing; }
                            .calibration-rect { stroke: #ffff00; stroke-width: 2; fill: rgba(255,255,0,0.1); }
                        </style>
                    </defs>
                    <polygon points="${pointsStr}" class="calibration-rect"/>
                    ${greenLine}
                    ${handles}
                </svg>
            `;

            container.innerHTML = svgContent;

            // Add drag listeners
            addCalibrationPreviewDragListeners();
        }

        // Add drag listeners to calibration preview handles
        function addCalibrationPreviewDragListeners() {
            const container = document.getElementById('calibrationPreview');
            const svg = container.querySelector('svg');
            const handles = document.querySelectorAll('#calibrationPreview .calibration-handle');
            let draggedCorner = null;
            let startX, startY;
            let hasDragged = false;

            handles.forEach(handle => {
                const circle = handle.querySelector('circle');
                if (!circle) return;

                circle.addEventListener('mousedown', (e) => {
                    draggedCorner = parseInt(handle.getAttribute('data-index'));
                    startX = e.clientX;
                    startY = e.clientY;
                    hasDragged = false;
                    
                    // Select this corner
                    selectCalibrationCorner(draggedCorner);
                    
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering SVG click
                });

                circle.addEventListener('touchstart', (e) => {
                    draggedCorner = parseInt(handle.getAttribute('data-index'));
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    hasDragged = false;
                    
                    // Select this corner
                    selectCalibrationCorner(draggedCorner);
                    
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering SVG click
                });
            });

            // Add click listener to SVG to select closest corner
            if (svg) {
                svg.addEventListener('click', (e) => {
                    // Only select if not dragging
                    if (hasDragged) {
                        return;
                    }

                    const rect = svg.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    // Get SVG dimensions
                    const svgWidth = svg.viewBox.baseVal.width;
                    const svgHeight = svg.viewBox.baseVal.height;
                    const scaleX = svgWidth / rect.width;
                    const scaleY = svgHeight / rect.height;
                    
                    // Convert click position to SVG coordinates
                    const svgX = clickX * scaleX;
                    const svgY = clickY * scaleY;
                    
                    // Find closest corner
                    let closestIndex = 0;
                    let minDistance = Infinity;
                    
                    calibrationPoints.forEach((point, index) => {
                        const px = point.x * (svgWidth / (projectorTarget.width || 1920));
                        const py = point.y * (svgHeight / (projectorTarget.height || 1080));
                        const distance = Math.sqrt((svgX - px) ** 2 + (svgY - py) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });
                    
                    selectCalibrationCorner(closestIndex);
                });
            }

            document.addEventListener('mousemove', (e) => {
                if (draggedCorner !== null) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    // Check if we actually moved (threshold to avoid accidental drags)
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                        hasDragged = true;
                    }
                    updateCalibrationPointDrag(draggedCorner, dx, dy);
                    startX = e.clientX;
                    startY = e.clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (draggedCorner !== null) {
                    const dx = e.touches[0].clientX - startX;
                    const dy = e.touches[0].clientY - startY;
                    // Check if we actually moved (threshold to avoid accidental drags)
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                        hasDragged = true;
                    }
                    updateCalibrationPointDrag(draggedCorner, dx, dy);
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            document.addEventListener('mouseup', () => {
                draggedCorner = null;
                hasDragged = false;
            });
            document.addEventListener('touchend', () => {
                draggedCorner = null;
                hasDragged = false;
            });
        }

        // Update calibration point during drag
        function updateCalibrationPointDrag(index, dxPx, dyPx) {
            if (index < 0 || index > 3) return;
            
            // Convert drag distance from SVG pixels back to projector pixels
            const width = projectorTarget.width || 1920;
            const height = projectorTarget.height || 1080;
            const maxWidth = 600;
            const scale = width / maxWidth;
            
            const dx = dxPx * scale;
            const dy = dyPx * scale;
            
            const point = calibrationPoints[index];
            if (point) {
                point.x = Math.max(0, Math.min(width, point.x + dx));
                point.y = Math.max(0, Math.min(height, point.y + dy));
                
                renderCalibrationPreview();
                
                // Send update to projector
                if (window.socket && calibrationMode) {
                    window.socket.emit('update_calibration_points', {
                        points: calibrationPoints
                    });
                }
            }
        }

        // Nudge calibration corner using arrow buttons
        function nudgeCalibrationCorner(dx_px, dy_px) {
            if (selectedCalibrationCorner === null) {
                return; // Silently ignore if no corner selected
            }
            
            const width = projectorTarget.width || 1920;
            const height = projectorTarget.height || 1080;
            
            const point = calibrationPoints[selectedCalibrationCorner];
            if (point) {
                point.x = Math.max(0, Math.min(width, point.x + dx_px));
                point.y = Math.max(0, Math.min(height, point.y + dy_px));
                
                renderCalibrationPreview();
                
                // Send update to projector
                if (window.socket && calibrationMode) {
                    window.socket.emit('update_calibration_points', {
                        points: calibrationPoints
                    });
                }
            }
        }

        function saveCalibration() {
            return showConfirmModal('Save calibration?', performSaveCalibration, 'Save');
        }

        function performSaveCalibration() {
            const width = parseFloat(document.getElementById('pressWidth').value);
            const height = parseFloat(document.getElementById('pressHeight').value);
            
            if (!width || !height) {
                showAlert('Please enter press dimensions', 'error');
                return;
            }
            
            // Ensure we have 4 valid points; don't require interactive mode to be currently active
            if (!Array.isArray(calibrationPoints) || calibrationPoints.length !== 4 ||
                calibrationPoints.some(p => p == null || isNaN(p.x) || isNaN(p.y))) {
                showAlert('Calibration points incomplete. Please run interactive calibration and set all 4 corners.', 'error');
                return;
            }
            
            // Use interactive calibration points
            const projectorPixels = calibrationPoints.map(p => [p.x, p.y]);
            // Destination should be the raster canvas size (pre-warp), use projector target resolution
            const W = projectorTarget.width;
            const H = projectorTarget.height;
            const destinationPoints = [
                [0, 0],
                [W, 0],
                [W, H],
                [0, H]
            ];

            fetch('/api/calibration', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    projector_pixels: projectorPixels,
                    target_pixels: { width: W, height: H },
                    press_width_mm: width,
                    press_height_mm: height
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('Calibration saved successfully', 'success');
                    // Stop calibration mode
                    if (calibrationMode) {
                        stopInteractiveCalibration();
                    }
                    // Hide validation pattern (corners) after confirming new calibration
                    if (validationVisible) {
                        window.socket.emit('hide_validation_pattern');
                        validationVisible = false;
                        const btn = document.getElementById('validateBtn');
                        if (btn) btn.textContent = 'Show configured Area';
                    }
                } else {
                    showAlert('Calibration failed: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showAlert('Error saving calibration: ' + error, 'error');
            });
        }

let validationVisible = false;
function validateCalibration() {
    const btn = document.getElementById('validateBtn');
    if (!window.socket) return;
    if (validationVisible) {
        window.socket.emit('hide_validation_pattern');
        try { window.socket.emit('set_projection_mode', { mode: 'frames' }); } catch (e) {}
        // Immediately re-render and send current scene so it shows again without further edits
        try { setTimeout(() => renderControlPreview(), 50); } catch (e) {}
        validationVisible = false;
        if (btn) btn.textContent = 'Show configured Area';
    } else {
        window.socket.emit('show_validation_pattern');
        try { window.socket.emit('set_projection_mode', { mode: 'svg' }); } catch (e) {}
        validationVisible = true;
        if (btn) btn.textContent = 'Hide';
    }
}

        // loadCalibration removed from UI; keeping function is unnecessary, so it's removed.

        // Layout functions
        function updateObjectOrientation() {
            // If user is holding the spinner button, accept only the first generated change
            if (orientationSpinHold.active) {
                if (orientationSpinHold.processed) {
                    return;
                }
                orientationSpinHold.processed = true;
            }
            const angle = parseFloat(document.getElementById('objectOrientation').value) || 0;
            currentLayout.object_orientation = angle;
            // Debounce both layout update and rasterization send to avoid flooding
            try { scheduleLayoutUpdateDebounced(60); } catch (e) { try { sendLayoutUpdate(); } catch (e2) {} }
            try {
                suppressImmediateRender = true;
                renderControlPreview();
            } finally {
                suppressImmediateRender = false;
            }
            try { scheduleRenderSendDebounced(window.__lastRootNode || previewDraw.node, 80); } catch (e) {}
        }

        function updateCenterLines() {
            const hRaw = document.getElementById('centerLineH').value;
            const vRaw = document.getElementById('centerLineV').value;
            const hParsed = parseFloat(hRaw);
            const vParsed = parseFloat(vRaw);
            const h = Number.isNaN(hParsed) ? null : hParsed; // preserve 0
            const v = Number.isNaN(vParsed) ? null : vParsed; // preserve 0
            currentLayout.center_lines = { horizontal: h, vertical: v };
            sendLayoutUpdate();
            renderControlPreview();
        }

        function sendLayoutUpdate() {
            if (window.socket) {
                // Include elements in currentLayout
                currentLayout.elements = elements;
                window.socket.emit('layout_update', currentLayout);
            }
        }

        function startNewScene() {
            // Step 1: Confirm starting a new scene
            return showConfirmModal('Start a new scene?', () => {
                // Step 2: If there are elements, offer to save first
                if (Array.isArray(elements) && elements.length > 0) {
                    showConfirmModal('Save current scene before clearing?', () => {
                        const nameInput = document.getElementById('configName');
                        const name = nameInput ? nameInput.value : '';
                        if (!name) {
                            showAlert('Enter a scene name in the input to save first.', 'error');
                            try { nameInput && nameInput.focus(); } catch (e) {}
                            // Do not proceed; user can click New again after naming
                            return;
                        }
                        // Save, then proceed to clear immediately after triggering save
                        try { performSaveConfiguration(); } catch (e) {}
                        performStartNewScene();
                    }, 'Save');
                } else {
                    // No elements; just clear
                    performStartNewScene();
                }
            }, 'New');
        }

        function performStartNewScene() {
            elements = [];
            selectedElementIndex = -1;
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
            showAlert('New scene started. Orientation and center lines preserved.', 'success');
        }

        // Drawing tools
        function addLine() {
            const element = {
                type: 'line',
                start: [0, 0],
                end: [50, 50],
                label: 'Line ' + (elements.length + 1)
            };
            elements.push(element);
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
        }

        function addRectangle() {
            const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
            const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;
            const w = 50;
            const h = 30;
            const cx = pressW / 2 - w / 2;
            const cy = pressH / 2 - h / 2;
            const element = {
                type: 'rectangle',
                position: [cx, cy],
                width: w,
                height: h,
                rotation: 0,
                label: 'Rectangle ' + (elements.length + 1)
            };
            elements.push(element);
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
        }

        function addCircle() {
            const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
            const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;
            const r = 20;
            const cx = pressW / 2;
            const cy = pressH / 2;
            const element = {
                type: 'circle',
                position: [cx, cy],
                radius: r,
                label: 'Circle ' + (elements.length + 1)
            };
            elements.push(element);
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
        }

        function addImage() {
            showImageSelection();
        }

        function showImageSelection() {
            const modal = document.getElementById('imageSelectionModal');
            const list = document.getElementById('imageSelectionList');
            
            // Close modal when clicking outside
            modal.onclick = (e) => {
                if (e.target === modal) closeImageSelection();
            };
            
            // Show modal immediately
            modal.style.display = 'flex';
            
            // Refresh files list and populate
            loadFiles().then(() => {
                populateImageSelectionList(list);
            });
        }

        async function populateImageSelectionList(list) {
            // Populate with uploaded images
            list.innerHTML = '';
            
            console.log('Populating image selection with files:', files);
            
            if (files.length === 0) {
                list.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #666;">No images uploaded yet. Upload images in the Files tab.</p>';
            } else {
                // Display images with direct URLs
                for (const file of files) {
                    const item = document.createElement('div');
                    item.style.cssText = 'cursor: pointer; text-align: center; border: 2px solid #ddd; border-radius: 8px; padding: 0.5rem; transition: border-color 0.2s;';

                    const imageUrl = toAbsoluteUrl(file.url || `/uploads/${file.filename}`);
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.style.cssText = 'width: 100%; height: 80px; object-fit: contain; border-radius: 4px; background: #f5f5f5;';
                    img.onerror = async function() {
                        try {
                            const res = await fetch(`/api/files/${encodeURIComponent(file.filename)}/base64`);
                            const data = await res.json();
                            if (data && data.data_url) {
                                img.onerror = null;
                                img.src = data.data_url;
                            } else {
                                item.innerHTML = '<div style="padding: 20px; color: #999;">Failed to load</div>';
                            }
                        } catch (e) {
                            item.innerHTML = '<div style="padding: 20px; color: #999;">Failed to load</div>';
                        }
                    };

                    const name = document.createElement('p');
                    name.textContent = file.filename || 'Unknown';
                    name.style.cssText = 'margin-top: 0.5rem; font-size: 0.85rem; color: #333; word-break: break-word;';

                    item.appendChild(img);
                    item.appendChild(name);
                    list.appendChild(item);

                    item.addEventListener('mouseenter', () => { item.style.borderColor = '#3498db'; });
                    item.addEventListener('mouseleave', () => { item.style.borderColor = '#ddd'; });
                    item.addEventListener('click', () => { selectImageForElement(file); });
                }
            }
        }

        function closeImageSelection() {
            const modal = document.getElementById('imageSelectionModal');
            modal.style.display = 'none';
        }

        function selectImageForElement(file) {
            closeImageSelection();
            
            const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
            const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;
            const element = {
                type: 'image',
                position: [pressW / 2, pressH / 2],
                width: 40,
                rotation: 0,
                image_url: toAbsoluteUrl(file.url || '/uploads/' + file.filename),
                color: '#00ffff',
                opacity: 0.5,
                label: 'Image ' + (elements.length + 1)
            };
            elements.push(element);
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
        }

        function addText() {
            const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
            const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;
            const x = pressW / 2;
            const y = pressH / 2;
            const element = {
                type: 'text',
                position: [x, y],
                rotation: 0,
                font_size: 10,
                text: 'Sample Text',
                color: '#00ffff',
                label: 'Text ' + (elements.length + 1)
            };
            elements.push(element);
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
        }

        function updateElementList() {
            const list = document.getElementById('elementList');
            list.innerHTML = '';
            
            elements.forEach((element, index) => {
                const item = document.createElement('div');
                item.className = 'element-item';
                item.innerHTML = `
                    <span>${element.label}</span>
                    <div class="element-controls">
                        <button onclick="editElement(${index})">Edit</button>
                        <button onclick="removeElement(${index})">Remove</button>
                    </div>
                `;
                if (index === selectedElementIndex) item.classList.add('selected');

                // Click selects item, shows nudge controls, and blinks the element
                item.addEventListener('click', function(e) {
                    if (e.target.closest('button')) return;
                    setSelectedElement(index);
                    blinkElement(index);
                });
                
                list.appendChild(item);
            });

            updateNudgeControlsVisibility();
        }

        // Global storage for blink timers
        const blinkTimers = {};
        
        function blinkElement(index) {
            // Find the SVG group with class el-{index}
            if (!previewDraw) return;
            
            // Stop any existing blink animation for this element
            if (blinkTimers[index]) {
                clearTimeout(blinkTimers[index].timeout);
                if (blinkTimers[index].group) {
                    blinkTimers[index].group.opacity(1);
                }
            }
            
            const svgGroups = previewDraw.find('.el-' + index);
            if (svgGroups && svgGroups.length > 0) {
                const group = svgGroups[0];
                
                // Create blinking animation
                const startTime = Date.now();
                const duration = 2000; // 2 seconds
                const blinkInterval = 500; // Blink every 0.5 seconds
                let isVisible = true;
                let timeoutId = null;
                
                const blink = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed < duration) {
                        isVisible = !isVisible;
                        group.opacity(isVisible ? 1 : 0.2);
                        timeoutId = setTimeout(blink, blinkInterval / 2);
                    } else {
                        // Restore normal state
                        group.opacity(1);
                        delete blinkTimers[index];
                    }
                };
                
                // Store timer reference
                blinkTimers[index] = { group, timeout: timeoutId };
                
                // Start blinking immediately
                isVisible = false;
                group.opacity(0.2);
                timeoutId = setTimeout(blink, blinkInterval / 2);
                blinkTimers[index].timeout = timeoutId;
            }
        }

        let eeIndex = -1;
        let eeKeyHandler = null;
        function editElement(index) {
            eeIndex = index;
            const element = elements[index];
            const editor = document.getElementById('elementEditor');
            const label = document.getElementById('eeLabel');
            const color = document.getElementById('eeColor');
            const commonFields = document.getElementById('eeCommonFields');
            const rectFields = document.getElementById('eeRectFields');
            const lineFields = document.getElementById('eeLineFields');
            const circleFields = document.getElementById('eeCircleFields');
            const textFields = document.getElementById('eeTextFields');
            const imageFields = document.getElementById('eeImageFields');

            label.value = element.label || '';
            color.value = normalizeColorForInput(element.color || '#00ffff');
            
            // Show/hide common fields based on element type
            const showCommonFields = ['rectangle', 'circle', 'text', 'image', 'line'].includes(element.type);
            commonFields.style.display = showCommonFields ? 'block' : 'none';
            
            // Show/hide type-specific fields
            rectFields.style.display = element.type === 'rectangle' ? 'block' : 'none';
            lineFields.style.display = element.type === 'line' ? 'block' : 'none';
            circleFields.style.display = element.type === 'circle' ? 'block' : 'none';
            textFields.style.display = element.type === 'text' ? 'block' : 'none';
            imageFields.style.display = element.type === 'image' ? 'block' : 'none';
            
            // Populate common fields based on element type
            if (element.type === 'rectangle' || element.type === 'circle' || element.type === 'text' || element.type === 'image') {
                const [x, y] = element.position || [0, 0];
                document.getElementById('eeX').value = x != null ? x.toFixed(1) : '';
                document.getElementById('eeY').value = y != null ? y.toFixed(1) : '';
                document.getElementById('eeRotation').value = element.rotation != null ? element.rotation : 0;
            } else if (element.type === 'line') {
                // Lines compute x, y from start/end points
                const [x1,y1] = element.start || [0,0];
                const [x2,y2] = element.end || [0,0];
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;
                const ang = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                document.getElementById('eeX').value = mx.toFixed(1);
                document.getElementById('eeY').value = my.toFixed(1);
                document.getElementById('eeRotation').value = ang.toFixed(1);
            }
            
            // Type-specific field population
            if (element.type === 'rectangle') {
                document.getElementById('eeWidth').value = element.width != null ? element.width : '';
                document.getElementById('eeHeight').value = element.height != null ? element.height : '';
            } else if (element.type === 'circle') {
                document.getElementById('eeRadius').value = element.radius != null ? element.radius : '';
            } else if (element.type === 'text') {
                document.getElementById('eeTextSize').value = element.font_size != null ? element.font_size : 10;
                document.getElementById('eeTextContent').value = element.text != null ? element.text : '';
            } else if (element.type === 'image') {
                document.getElementById('eeImageWidth').value = element.width != null ? element.width : '';
                document.getElementById('eeImageRotation').value = element.rotation != null ? element.rotation : 0;
                // Opacity fields (store as 0..1, UI shows 0..100)
                try {
                    const op = (typeof element.opacity === 'number' && element.opacity >= 0 && element.opacity <= 1) ? element.opacity : 0.5;
                    const opPct = Math.round(op * 100);
                    const slider = document.getElementById('eeImageOpacity');
                    const numeric = document.getElementById('eeImageOpacityNum');
                    if (slider) slider.value = String(opPct);
                    if (numeric) numeric.value = String(opPct);
                    // Live update while sliding/typing
                    const syncFromSlider = (val) => {
                        const pct = Math.max(0, Math.min(100, Number(val)));
                        if (numeric) numeric.value = String(pct);
                        try { elements[eeIndex].opacity = pct / 100; } catch (err) {}
                        renderControlPreview();
                    };
                    const syncFromNumeric = (val) => {
                        const pct = Math.max(0, Math.min(100, Number(val)));
                        if (slider) slider.value = String(pct);
                        try { elements[eeIndex].opacity = pct / 100; } catch (err) {}
                        renderControlPreview();
                    };
                    if (slider) {
                        slider.oninput = (e) => syncFromSlider(e.target.value);
                        slider.onchange = (e) => syncFromSlider(e.target.value);
                    }
                    if (numeric) {
                        numeric.oninput = (e) => syncFromNumeric(e.target.value);
                        numeric.onchange = (e) => syncFromNumeric(e.target.value);
                    }
                } catch (e) {}
            }

            // live color preview while picker is open
            color.oninput = (e) => {
                try { elements[eeIndex].color = e.target.value; } catch (err) {}
                renderControlPreview();
            };

            // click outside to close
            editor.onclick = (e) => { if (e.target === editor) closeElementEditor(); };

            // keyboard: Escape => cancel (do not bind 's' or 'Enter' to save to avoid interfering with typing)
            eeKeyHandler = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeElementEditor();
                }
            };
            document.addEventListener('keydown', eeKeyHandler);

            editor.style.display = 'flex';
        }

        function closeElementEditor() {
            const editor = document.getElementById('elementEditor');
            editor.style.display = 'none';
            try { document.getElementById('eeColor').blur(); } catch (err) {}
            if (eeKeyHandler) {
                document.removeEventListener('keydown', eeKeyHandler);
                eeKeyHandler = null;
            }
            eeIndex = -1;
        }

        function saveElementEditor() {
            if (eeIndex < 0) return;
            const element = elements[eeIndex];
            const label = document.getElementById('eeLabel').value;
            const color = document.getElementById('eeColor').value;

            element.label = label;
            element.color = color;
            
            // Read common fields (X, Y, Rotation)
            const x = parseFloat(document.getElementById('eeX').value);
            const y = parseFloat(document.getElementById('eeY').value);
            const rotation = parseFloat(document.getElementById('eeRotation').value);
            
            if (element.type === 'rectangle') {
                const w = parseFloat(document.getElementById('eeWidth').value);
                const h = parseFloat(document.getElementById('eeHeight').value);
                if (!Number.isNaN(x) && !Number.isNaN(y)) element.position = [x, y];
                if (!Number.isNaN(rotation)) element.rotation = rotation;
                if (!Number.isNaN(w) && w >= 0) element.width = w;
                if (!Number.isNaN(h) && h >= 0) element.height = h;
            } else if (element.type === 'line') {
                // Lines reconstruct start/end from center point and rotation
                if (!Number.isNaN(x) && !Number.isNaN(y) && !Number.isNaN(rotation)) {
                    const [x1,y1] = element.start || [0,0];
                    const [x2,y2] = element.end || [0,0];
                    const len = Math.hypot(x2 - x1, y2 - y1);
                    const half = len / 2;
                    const rad = rotation * Math.PI / 180;
                    const dx = Math.cos(rad) * half;
                    const dy = Math.sin(rad) * half;
                    element.start = [x - dx, y - dy];
                    element.end = [x + dx, y + dy];
                }
            } else if (element.type === 'circle') {
                const r = parseFloat(document.getElementById('eeRadius').value);
                if (!Number.isNaN(x) && !Number.isNaN(y)) element.position = [x, y];
                if (!Number.isNaN(rotation)) element.rotation = rotation;
                if (!Number.isNaN(r) && r >= 0) element.radius = r;
            } else if (element.type === 'text') {
                const ts = parseFloat(document.getElementById('eeTextSize').value);
                const tc = String(document.getElementById('eeTextContent').value || '');
                if (!Number.isNaN(x) && !Number.isNaN(y)) element.position = [x, y];
                if (!Number.isNaN(rotation)) element.rotation = rotation;
                if (!Number.isNaN(ts) && ts >= 0) element.font_size = ts;
                element.text = tc;
            } else if (element.type === 'image') {
                const iw = parseFloat(document.getElementById('eeImageWidth').value);
                if (!Number.isNaN(x) && !Number.isNaN(y)) element.position = [x, y];
                if (!Number.isNaN(rotation)) element.rotation = rotation;
                if (!Number.isNaN(iw) && iw >= 0) element.width = iw;
                // Save opacity (0..1) from UI (0..100)
                try {
                    const pct = Number(document.getElementById('eeImageOpacity').value);
                    if (!Number.isNaN(pct)) element.opacity = Math.max(0, Math.min(100, pct)) / 100;
                } catch (e) {}
            }

            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
            closeElementEditor();
        }

        function normalizeColorForInput(c) {
            // Accepts #rgb, #rrggbb or css color names; if invalid, fallback
            const ctx = document.createElement('canvas').getContext('2d');
            if (!ctx) return '#00ffff';
            ctx.fillStyle = '#000';
            ctx.fillStyle = c;
            const computed = ctx.fillStyle;
            // Convert rgb(a) to hex
            if (computed.startsWith('rgb')) {
                const m = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (m) {
                    const r = Number(m[1]).toString(16).padStart(2, '0');
                    const g = Number(m[2]).toString(16).padStart(2, '0');
                    const b = Number(m[3]).toString(16).padStart(2, '0');
                    return `#${r}${g}${b}`;
                }
            }
            if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(computed)) return computed;
            return '#00ffff';
        }

        let pendingDeleteIndex = null;

        function removeElement(index) {
            const element = elements[index];
            const elementName = element ? element.label : 'this element';
            pendingDeleteIndex = index;
            
            document.getElementById('deleteElementName').textContent = `"${elementName}"`;
            showDeleteElementModal();
        }

        function showDeleteElementModal() {
            const modal = document.getElementById('deleteElementModal');
            if (modal) modal.style.display = 'flex';
            // Focus cancel button for quick keyboard interaction
            try { document.getElementById('deleteConfirmBtn').focus(); } catch (e) {}
        }

        function hideDeleteElementModal() {
            const modal = document.getElementById('deleteElementModal');
            if (modal) modal.style.display = 'none';
            pendingDeleteIndex = null;
        }

        // Generic confirmation modal helpers
        let pendingConfirmAction = null;
        function showConfirmModal(message, onConfirm, confirmLabel = 'Confirm') {
            const modal = document.getElementById('confirmModal');
            const msgEl = document.getElementById('confirmMessage');
            const okBtn = document.getElementById('confirmOkBtn');
            if (!modal || !msgEl || !okBtn) return;
            msgEl.textContent = message;
            okBtn.textContent = confirmLabel;
            pendingConfirmAction = typeof onConfirm === 'function' ? onConfirm : null;
            modal.style.display = 'flex';
            try { okBtn.focus(); } catch (e) {}
        }
        function hideConfirmModal() {
            const modal = document.getElementById('confirmModal');
            if (modal) modal.style.display = 'none';
            pendingConfirmAction = null;
        }
        function confirmFromModal() {
            if (pendingConfirmAction) {
                const fn = pendingConfirmAction;
                pendingConfirmAction = null;
                try { fn(); } catch (e) {}
            }
            hideConfirmModal();
        }

        function confirmDeleteElement() {
            if (pendingDeleteIndex === null) return;
            
            const index = pendingDeleteIndex;
            elements.splice(index, 1);
            if (selectedElementIndex === index) {
                selectedElementIndex = -1;
            } else if (selectedElementIndex > index) {
                selectedElementIndex -= 1;
            }
            updateElementList();
            sendLayoutUpdate();
            renderControlPreview();
            
            hideDeleteElementModal();
        }

        // File management
        function handleFileUpload() {
            const input = document.getElementById('fileInput');
            const files = input.files;
            
            for (let file of files) {
                uploadFile(file);
            }
        }

        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/api/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('File uploaded successfully: ' + data.file.filename, 'success');
                    loadFiles();
                } else {
                    showAlert('Upload failed: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showAlert('Upload error: ' + error, 'error');
            });
        }

        function loadFiles() {
            return fetch('/api/files')
            .then(response => response.json())
            .then(data => {
                files = data.files || [];
                updateFileList();
                return files;
            })
            .catch(error => {
                showAlert('Error loading files: ' + error, 'error');
                return [];
            });
        }

        function updateFileList() {
            const list = document.getElementById('fileList');
            list.innerHTML = '';
            
            files.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <span>${file.filename} (${(file.size / 1024).toFixed(1)} KB)</span>
                `;
                list.appendChild(item);
            });
        }

        

        // Configuration management
        function saveConfiguration() {
            return showConfirmModal('Save scene configuration?', performSaveConfiguration, 'Save');
        }

        function performSaveConfiguration() {
            const name = document.getElementById('configName').value;
            if (!name) {
                showAlert('Please enter a configuration name', 'error');
                return;
            }

            const configData = {
                layout: currentLayout,
                elements: elements
            };

            fetch('/api/configurations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    data: configData
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('Configuration saved successfully', 'success');
                    loadConfigurations();
                } else {
                    showAlert('Save failed: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showAlert('Save error: ' + error, 'error');
            });
        }

        function loadConfigurations() {
            fetch('/api/configurations')
            .then(response => response.json())
            .then(data => {
                configurations = data.configurations;
                updateConfigurationList();
            })
            .catch(error => {
                showAlert('Error loading configurations: ' + error, 'error');
            });
        }

        function updateConfigurationList() {
            const list = document.getElementById('configurationList');
            list.innerHTML = '';
            
            configurations.forEach(config => {
                const item = document.createElement('div');
                item.className = 'element-item';
                item.innerHTML = `
                    <span>${config}</span>
                    <div class="element-controls">
                        <button onclick="loadConfiguration('${config}')">Load</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function loadConfiguration(name) {
            fetch('/api/configurations/' + name)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    showAlert('Configuration not found', 'error');
                    return;
                }
                
                currentLayout = data.layout;
                elements = data.elements || [];
                selectedElementIndex = -1;
                
                updateLayoutForm();
                updateElementList();
                sendLayoutUpdate();
                // Prefill scene name for quick save
                try { document.getElementById('configName').value = name; } catch (e) {}
                
                showAlert('Configuration loaded successfully', 'success');
            })
            .catch(error => {
                showAlert('Load error: ' + error, 'error');
            });
        }

        function fetchLastSceneAndAutoLoad() {
            fetch('/api/last-scene')
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                const last = data && data.name ? data.name : null;
                if (!last) return;
                // Only auto-load if it exists in the current list, otherwise try anyway
                loadConfiguration(last);
            })
            .catch(() => {});
        }

        function updateLayoutForm() {
            const orientationInput = document.getElementById('objectOrientation');
            const hInput = document.getElementById('centerLineH');
            const vInput = document.getElementById('centerLineV');

            // Only update fields that are not currently focused to avoid wiping user typing
            if (document.activeElement !== orientationInput) {
                orientationInput.value = currentLayout.object_orientation || 0;
            }
            if (document.activeElement !== hInput) {
                hInput.value = currentLayout.center_lines?.horizontal ?? '';
            }
            if (document.activeElement !== vInput) {
                vInput.value = currentLayout.center_lines?.vertical ?? '';
            }

            // Do not reset selection here to preserve user selection across updates
            updateNudgeControlsVisibility();
            renderControlPreview();
        }

        // Setup & Maintenance

        // Utility functions
        function showAlert(message, type) {
            const targetContainer = document.getElementById('alertsBelow');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            targetContainer.appendChild(alert);
            
            setTimeout(() => {
                alert.remove();
            }, 5000);
        }

        // ===== Control Preview (SVG.js) =====
        let previewDraw = null;
        let renderTimer = null;
        let projectorTarget = { width: 1920, height: 1080 };
        let pressSizeTimer = null;

        function setPressInputs(widthMm, heightMm) {
            console.log('Setting press inputs:', widthMm, heightMm);
            const pw = document.getElementById('pressWidth');
            const ph = document.getElementById('pressHeight');
            if (pw && widthMm != null && !Number.isNaN(widthMm)) {
                try { pw.valueAsNumber = Number(widthMm); } catch (e) {}
                pw.value = String(widthMm);
            }
            if (ph && heightMm != null && !Number.isNaN(heightMm)) {
                try { ph.valueAsNumber = Number(heightMm); } catch (e) {}
                ph.value = String(heightMm);
            }
        }

        function initControlPreview() {
            const container = document.getElementById('layoutPreview');
            container.innerHTML = '';
            previewDraw = SVG().addTo(container).size('100%', '100%');
            renderControlPreview();

            // Listen for projector resolution updates
            if (window.socket) {
                window.socket.on('projector_resolution', (data) => {
                    projectorTarget = { width: data.width, height: data.height };
                    document.getElementById('previewSize').textContent = `${projectorTarget.width}×${projectorTarget.height}`;
                    // Receiving projector resolution implies projector client is online
                    updateConnectionStatus(true);
                });
            }

            // Load current press size from backend (if calibrated)
            fetch('/api/press-size')
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (data && data.press_width_mm && data.press_height_mm) {
                        setPressInputs(data.press_width_mm, data.press_height_mm);
                        renderControlPreview();
                    }
                }).catch(() => {});

            // Wire inputs to save (debounced)
            const pw = document.getElementById('pressWidth');
            const ph = document.getElementById('pressHeight');
            const onPressSizeChange = () => {
                if (pressSizeTimer) clearTimeout(pressSizeTimer);
                pressSizeTimer = setTimeout(savePressSize, 500);
                renderControlPreview();
            };
            pw.addEventListener('input', onPressSizeChange);
            ph.addEventListener('input', onPressSizeChange);
        }

        let suppressImmediateRender = false;
        function renderControlPreview() {
            if (!previewDraw) return;
            const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
            const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;

            previewDraw.clear();

            // Root group with viewBox in mm coordinates
            const root = previewDraw.nested().viewbox(0, 0, pressW, pressH).attr({ preserveAspectRatio: 'xMidYMid meet' });
            // Remember the last root node used for rasterization sends
            try { window.__lastRootNode = root.node; } catch (e) {}

            // Optional: draw press boundary
            root.rect(pressW, pressH).fill('none').stroke({ color: '#444', width: 0.5 });

            // Apply base rotation around press center if any
            const angle = currentLayout.object_orientation || 0;
            const rotGroup = root.group();
            if (angle) {
                rotGroup.rotate(angle, pressW / 2, pressH / 2);
            }

            // Center lines should rotate with object orientation; draw within rotGroup
            const over = Math.max(pressW, pressH) * 2;
            if (currentLayout.center_lines?.horizontal != null) {
                const y = currentLayout.center_lines.horizontal;
                rotGroup.line(-over, y, pressW + over, y).stroke({ color: '#ff0000', width: 0.6, dasharray: '8,4' });
            }
            if (currentLayout.center_lines?.vertical != null) {
                const x = currentLayout.center_lines.vertical;
                rotGroup.line(x, -over, x, pressH + over).stroke({ color: '#ff0000', width: 0.6, dasharray: '8,4' });
            }

            // Elements
            (elements || []).forEach((el, idx) => {
                const g = rotGroup.group();
                g.addClass('el-' + idx);
                // Select element on pointer down so arrow keys can adjust it
                g.on('mousedown', () => setSelectedElement(idx));
                g.on('touchstart', () => setSelectedElement(idx));
                if (el.type === 'line') {
                    const [x1, y1] = el.start || [0, 0];
                    const [x2, y2] = el.end || [0, 0];
                    // Compute extended drawing endpoints so lines remain visible when rotated
                    const mx = (x1 + x2) / 2;
                    const my = (y1 + y2) / 2;
                    const vx = x2 - x1;
                    const vy = y2 - y1;
                    const vlen = Math.hypot(vx, vy) || 1;
                    const ux = vx / vlen;
                    const uy = vy / vlen;
                    const over = Math.max(pressW, pressH) * 2;
                    const drawHalf = vlen / 2 + over;
                    const dx = ux * drawHalf;
                    const dy = uy * drawHalf;
                    const dx1 = mx - dx;
                    const dy1 = my - dy;
                    const dx2 = mx + dx;
                    const dy2 = my + dy;
                    const lg = g.group();
                    // Visible extended line
                    lg.line(dx1, dy1, dx2, dy2).stroke({ color: el.color || '#0ff', width: 0.6, dasharray: '5,5' });
                    // Transparent, thicker hit line for easier dragging
                    lg.line(dx1, dy1, dx2, dy2)
                        .stroke({ color: '#000', width: 6, opacity: 0.001 })
                        .attr('pointer-events', 'stroke')
                        .css('cursor', 'grab');
                    if (el.label) lg.text(el.label).font({ size: 6 }).fill('#fff').move((x1 + x2) / 2, (y1 + y2) / 2 - 2).attr('text-anchor', 'middle');
                    if (typeof lg.draggable === 'function') {
                        lg.draggable();
                        // Ensure selection when dragging starts
                        lg.on('dragstart', () => setSelectedElement(idx));
                        lg.on('dragend', () => {
                            // Get the current position after drag and convert back to mm
                            const bbox = lg.bbox();
                            const vb = lg.root().viewbox();
                            const sx = vb.width / lg.root().node.getBoundingClientRect().width;
                            const sy = vb.height / lg.root().node.getBoundingClientRect().height;
                            
                            // Calculate the center of the dragged line
                            const newCenterX = bbox.cx;
                            const newCenterY = bbox.cy;
                            
                            // Calculate the offset from original center
                            const originalCenterX = (x1 + x2) / 2;
                            const originalCenterY = (y1 + y2) / 2;
                            const offsetX = newCenterX - originalCenterX;
                            const offsetY = newCenterY - originalCenterY;
                            
                            // Update the element with the new positions
                            el.start = [x1 + offsetX, y1 + offsetY];
                            el.end = [x2 + offsetX, y2 + offsetY];
                            
                            sendLayoutUpdate();
                            renderControlPreview();
                        });
                    }
                } else if (el.type === 'rectangle') {
                    const [x, y] = el.position || [0, 0];
                    const w = el.width || 10;
                    const h = el.height || 10;
                    const r = el.rotation || 0;
                    const rr = g.group();
                    if (r) rr.rotate(r, x + w / 2, y + h / 2);
                    const rect = rr.rect(w, h).move(x, y).fill('none').stroke({ color: el.color || '#0ff', width: 0.6 });
                    if (el.label) {
                        const txt = rr.text(el.label).font({ size: 6, anchor: 'middle' }).fill('#fff').center(x + w / 2, y + h / 2);
                        txt.node.setAttribute('dominant-baseline', 'middle');
                    }
                    // Enable plugin-based dragging and update model on drag end
                    if (typeof rr.draggable === 'function') {
                        rr.draggable();
                        rr.on('dragstart', () => setSelectedElement(idx));
                        rr.on('dragend', () => {
                            const bb = rr.bbox();
                            el.position = [bb.x, bb.y];
                            renderControlPreview();
                        });
                    }
                } else if (el.type === 'circle') {
                    const [x, y] = el.position || [0, 0];
                    const r = el.radius || 5;
                    const cg = g.group();
                    const cc = cg.circle(r * 2).move(x - r, y - r).fill('none').stroke({ color: el.color || '#0ff', width: 0.6 });
                    if (el.label) cg.text(el.label).font({ size: 6 }).fill('#fff').move(x, y + 2).attr('text-anchor', 'middle');
                    if (typeof cg.draggable === 'function') {
                        cg.draggable();
                        cg.on('dragstart', () => setSelectedElement(idx));
                        cg.on('dragend', () => {
                            // Use visible circle bbox to derive center
                            const bb = cc.bbox();
                            const cx = bb.cx; const cy = bb.cy;
                            el.position = [cx, cy];
                            renderControlPreview();
                        });
                    }
                } else if (el.type === 'text') {
                    const [x, y] = el.position || [0, 0];
                    const fs = el.font_size || 10;
                    const rot = el.rotation || 0;
                    const tg = g.group();
                    if (rot) tg.rotate(rot, x, y);
                    const tnode = tg.text(el.text || '').font({ size: fs }).fill(el.color || '#0ff').move(x, y);
                    if (typeof tg.draggable === 'function') {
                        tg.draggable();
                        tg.on('dragstart', () => setSelectedElement(idx));
                        tg.on('dragend', () => {
                            const bb = tg.bbox();
                            el.position = [bb.x, bb.y];
                            renderControlPreview();
                        });
                    }
                } else if (el.type === 'image') {
                    const [x, y] = el.position || [0, 0];
                    const w = el.width || 20;
                    const r = el.rotation || 0;
                    const color = el.color || '#00ffff';
                    const url = el.image_url || '';
                    const ig = g.group();
                    // Create image and border, update height after natural size is known
                    window.__imgAspectCache = window.__imgAspectCache || {};
                    let h = el.height || w;
                    const cachedRatio = window.__imgAspectCache[url];
                    if (typeof cachedRatio === 'number' && cachedRatio > 0) {
                        h = w * cachedRatio;
                    }
                    const img = ig.image(url).size(w, h).move(x, y).opacity(0.5);
                    const border = ig.rect(w, h).move(x, y).fill('none').stroke({ color: color, width: 0.6 });
                    const label = el.label ? ig.text(el.label).font({ size: 6 }).fill('#fff').attr('text-anchor', 'middle') : null;
                    // Apply configured opacity if present (0..1)
                    try {
                        const op = (typeof el.opacity === 'number' && el.opacity >= 0 && el.opacity <= 1) ? el.opacity : 0.5;
                        img.opacity(op);
                    } catch (e) {}
                    function applySize(newH) {
                        h = newH > 0 ? newH : w;
                        img.size(w, h);
                        border.size(w, h);
                        el.height = h; // persist in model to avoid flicker on re-render
                        if (label) label.move(x + w / 2, y + h / 2);
                        if (r) {
                            const cx = x + w / 2, cy = y + h / 2;
                            img.rotate(r, cx, cy);
                            border.rotate(r, cx, cy);
                        }
                    }
                    if (label) label.move(x + w / 2, y + h / 2);
                    if (r) {
                        const cx0 = x + w / 2, cy0 = y + h / 2;
                        img.rotate(r, cx0, cy0);
                        border.rotate(r, cx0, cy0);
                    }
                    // Load to compute aspect ratio; handle absolute/relative URLs
                    try {
                        const pre = new Image();
                        pre.onload = () => {
                            if (pre.naturalWidth && pre.naturalHeight) {
                                const ratio = pre.naturalHeight / pre.naturalWidth;
                                window.__imgAspectCache[url] = ratio;
                                applySize(w * ratio);
                                // After correcting size, re-send SVG for rasterization
                                try { scheduleRenderSend(root.node); } catch (e) {}
                            }
                        };
                        pre.src = url;
                    } catch (e) {
                        // ignore aspect errors; keep square fallback
                    }
                    if (typeof ig.draggable === 'function') {
                        ig.draggable();
                        ig.on('dragstart', () => setSelectedElement(idx));
                        ig.on('dragend', () => {
                            const bb = ig.bbox();
                            el.position = [bb.x, bb.y];
                            renderControlPreview();
                        });
                    }
                }
            });

            // Debounced send to backend for rasterize+warp
            if (!suppressImmediateRender) {
                scheduleRenderSend(root.node);
            }
        }

        function makeDraggable(node, onDrop, moveTarget) {
            let start = null;
            const target = moveTarget || node;

            function getClientXY(e) {
                if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                return { x: e.clientX, y: e.clientY };
            }

            function onDown(e) {
                e.preventDefault();
                const pt = getClientXY(e);
                start = { x: pt.x, y: pt.y };
                try { e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); } catch (err) {}
                try { node.attr('pointer-events', 'all'); } catch (err) {}
                node.css('cursor', 'grabbing');
            }

            function onUp(e) {
                e.preventDefault();
                node.css('cursor', 'default');
                start = null;
                renderControlPreview();
            }

            function onMove(e) {
                if (!start) return;
                e.preventDefault();
                const pt = getClientXY(e);
                const bbox = node.root().node.getBoundingClientRect();
                const vb = node.root().viewbox();
                const sx = vb.width / bbox.width;
                const sy = vb.height / bbox.height;
                const dx = (pt.x - start.x) * sx;
                const dy = (pt.y - start.y) * sy;
                try { if (typeof target.dmove === 'function') target.dmove(dx, dy); } catch (err) {}
                onDrop(dx, dy);
                start = { x: pt.x, y: pt.y };
            }

            // Pointer + mouse + touch for robustness
            node.on('pointerdown', onDown);
            node.on('pointermove', onMove);
            node.on('pointerup', onUp);
            node.on('mousedown', onDown);
            node.on('mousemove', onMove);
            node.on('mouseup', onUp);
            node.on('touchstart', onDown);
            node.on('touchmove', onMove);
            node.on('touchend', onUp);
        }

        let renderSendTimer = null;
        function scheduleRenderSend(rootSvgNode) {
            if (!window.socket) return;
            if (renderTimer) cancelAnimationFrame(renderTimer);
            renderTimer = requestAnimationFrame(() => {
                // Wrap inner preview SVG content into a proper root SVG sized by projector ratio
                const pressW = parseFloat(document.getElementById('pressWidth').value) || 300;
                const pressH = parseFloat(document.getElementById('pressHeight').value) || 200;
                const inner = rootSvgNode.innerHTML || '';
                const svgString = `\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${pressW} ${pressH}" preserveAspectRatio="none">\n${inner}\n</svg>`;
                window.socket.emit('render_svg', {
                    svg: svgString,
                    target_width: projectorTarget.width,
                    target_height: projectorTarget.height
                });
                try { window.socket.emit('set_projection_mode', { mode: 'frames' }); } catch (e) {}
            });
        }

        function scheduleRenderSendDebounced(rootSvgNode, delayMs = 80) {
            if (!window.socket) return;
            if (renderSendTimer) clearTimeout(renderSendTimer);
            renderSendTimer = setTimeout(() => {
                scheduleRenderSend(rootSvgNode);
            }, delayMs);
        }

        function savePressSize() {
            const w = parseFloat(document.getElementById('pressWidth').value);
            const h = parseFloat(document.getElementById('pressHeight').value);
            if (!w || !h) return;
            fetch('/api/press-size', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ press_width_mm: w, press_height_mm: h })
            })
            .then(r => r.json())
            .then(data => {
                if (data && data.success) {
                    showAlert(`Press size saved: ${w}×${h}mm`, 'success');
                } else if (data && data.error) {
                    showAlert('Failed to save press size: ' + data.error, 'error');
                }
            })
            .catch(err => showAlert('Error saving press size: ' + err, 'error'));
        }

        // ===== Selection & Nudge/Rotate Controls =====
        function setSelectedElement(index) {
            selectedElementIndex = index;
            updateElementList();
            updateNudgeControlsVisibility();
        }

        function updateNudgeControlsVisibility() {
            const nc = document.getElementById('nudgeControls');
            if (!nc) return;
            nc.style.display = (selectedElementIndex >= 0 && elements[selectedElementIndex]) ? 'block' : 'none';
        }

        let layoutUpdateTimer = null;
        function scheduleLayoutUpdateDebounced(delayMs = 60) {
            if (layoutUpdateTimer) clearTimeout(layoutUpdateTimer);
            layoutUpdateTimer = setTimeout(() => {
                sendLayoutUpdate();
            }, delayMs);
        }

        function nudgeSelected(dx_mm, dy_mm) {
            if (selectedElementIndex < 0) return;
            const el = elements[selectedElementIndex];
            if (!el) return;
            if (el.type === 'line') {
                const [x1,y1] = el.start || [0,0];
                const [x2,y2] = el.end || [0,0];
                el.start = [x1 + dx_mm, y1 + dy_mm];
                el.end   = [x2 + dx_mm, y2 + dy_mm];
            } else if (el.type === 'rectangle' || el.type === 'circle' || el.type === 'text' || el.type === 'image') {
                const [x,y] = el.position || [0,0];
                el.position = [x + dx_mm, y + dy_mm];
            }
            suppressImmediateRender = true;
            renderControlPreview();
            suppressImmediateRender = false;
            scheduleLayoutUpdateDebounced();
            try { scheduleRenderSendDebounced(window.__lastRootNode || previewDraw.node, 80); } catch (e) {}
            updateElementList();
        }

        function rotateSelected(deltaRadians) {
            if (selectedElementIndex < 0) return;
            const el = elements[selectedElementIndex];
            if (!el) return;
            // Convert radians to degrees for elements that store rotation in degrees
            const deltaDeg = deltaRadians * 180 / Math.PI;
            if (el.type === 'rectangle' || el.type === 'text' || el.type === 'image') {
                const r = Number(el.rotation || 0);
                el.rotation = r + deltaDeg;
            } else if (el.type === 'line') {
                const [x1,y1] = el.start || [0,0];
                const [x2,y2] = el.end || [0,0];
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;
                const cx1 = x1 - mx, cy1 = y1 - my;
                const cx2 = x2 - mx, cy2 = y2 - my;
                const cosA = Math.cos(deltaRadians);
                const sinA = Math.sin(deltaRadians);
                const rx1 = cx1 * cosA - cy1 * sinA;
                const ry1 = cx1 * sinA + cy1 * cosA;
                const rx2 = cx2 * cosA - cy2 * sinA;
                const ry2 = cx2 * sinA + cy2 * cosA;
                el.start = [mx + rx1, my + ry1];
                el.end   = [mx + rx2, my + ry2];
            }
            suppressImmediateRender = true;
            renderControlPreview();
            suppressImmediateRender = false;
            scheduleLayoutUpdateDebounced();
            try { scheduleRenderSendDebounced(window.__lastRootNode || previewDraw.node, 80); } catch (e) {}
            updateElementList();
        }

        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                const active = document.activeElement;
                const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
                const anyModalOpen = (
                    document.getElementById('elementEditor')?.style.display === 'flex' ||
                    document.getElementById('imageSelectionModal')?.style.display === 'flex' ||
                    document.getElementById('stopCalibrationModal')?.style.display === 'flex' ||
                    document.getElementById('deleteElementModal')?.style.display === 'flex' ||
                    document.getElementById('confirmModal')?.style.display === 'flex'
                );
                if (isInput || anyModalOpen) return;

                // Handle calibration mode first
                if (calibrationMode && selectedCalibrationCorner !== null) {
                    if (e.key === 'ArrowUp') { e.preventDefault(); nudgeCalibrationCorner(0, -1); }
                    else if (e.key === 'ArrowDown') { e.preventDefault(); nudgeCalibrationCorner(0, 1); }
                    else if (e.key === 'ArrowLeft' && !e.shiftKey) { e.preventDefault(); nudgeCalibrationCorner(-1, 0); }
                    else if (e.key === 'ArrowRight' && !e.shiftKey) { e.preventDefault(); nudgeCalibrationCorner(1, 0); }
                    else if (e.key === 'Escape') { e.preventDefault(); selectCalibrationCorner(null); }
                } else {
                    // Normal element editing mode
                    if (e.key === 'Escape') { e.preventDefault(); setSelectedElement(-1); }
                    else if (e.key === 's' || e.key === 'S') { e.preventDefault(); saveConfiguration(); }
                    else if (e.key === 'e' || e.key === 'E') {
                        if (selectedElementIndex >= 0) {
                            e.preventDefault();
                            editElement(selectedElementIndex);
                        }
                    }
                    else if (e.key === 'ArrowUp') { e.preventDefault(); nudgeSelected(0, -1); }
                    else if (e.key === 'ArrowDown') { e.preventDefault(); nudgeSelected(0, 1); }
                    else if (e.key === 'ArrowLeft' && !e.shiftKey) { e.preventDefault(); nudgeSelected(-1, 0); }
                    else if (e.key === 'ArrowRight' && !e.shiftKey) { e.preventDefault(); nudgeSelected(1, 0); }
                    else if (e.shiftKey && e.key === 'ArrowLeft') { e.preventDefault(); rotateSelected(-Math.PI/180); }
                    else if (e.shiftKey && e.key === 'ArrowRight') { e.preventDefault(); rotateSelected(Math.PI/180); }
                    else if (e.key === 'Delete') {
                        if (selectedElementIndex >= 0) {
                            e.preventDefault();
                            removeElement(selectedElementIndex);
                        }
                    }
                }
            });
        }

        // Initialize preview after DOM is ready (with SVG.js availability check)
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('layoutPreview');
            if (!container) return;
            if (typeof SVG === 'undefined') {
                container.innerHTML = '<div style="color:#ddd;padding:12px;">Preview not available (SVG.js not loaded). Check network or bundle SVG.js locally.</div>';
                return;
            }
            initControlPreview();
            initKeyboardShortcuts();
        });
    </script>
</body>
</html>
